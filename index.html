<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Nối file PDF và hình</title>
  <link rel="icon" href="assets/favicon.png" type="image/png">
  <script src="lib/pdf-lib.min.js"></script>
  <script src="lib/pdf.min.js"></script>
  <script>
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'lib/pdf.worker.min.js';
  </script>
  <script src="lib/Sortable.min.js"></script>
  <style>
    body {
      font-family: sans-serif;
      background: #1e1e2f;
      color: #fff;
      padding: 20px;
    }

    h2 {
      margin-top: 30px;
    }

    .list {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    .page-thumb {
      border: 2px solid #555;
      padding: 5px;
      background: #2e2e3e;
      width: 120px;
      cursor: grab;
    }

    img,
    canvas {
      width: 100%;
      display: block;
    }

    button {
      margin-top: 20px;
      padding: 10px 15px;
      font-size: 16px;
    }
  </style>
</head>

<body>
  <h1>Nối file PDF và hình</h1>

  <input type="file" id="pdfInput" accept=".pdf" multiple/>
  <input type="file" id="imgInput" accept="image/*" multiple />

  <h2>Bản xem trước (kéo thả để sắp xếp thứ tự):</h2>
  <div id="pages" class="list"></div>

  <button id="exportBtn">Xuất file PDF</button>

  <script>
    let originalPdfFileName = 'combined';
    let pages = []; // { type: 'pdf'|'image', content: ArrayBuffer|Image }

    document.getElementById('pdfInput').addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      for (const file of e.target.files) {
        try {
          const pdfBytes = await file.arrayBuffer();
          const pdfDoc = await PDFLib.PDFDocument.load(pdfBytes);
          const pageCount = pdfDoc.getPageCount();
          for (let i = 0; i < pageCount; i++) {
            const copiedPdf = await PDFLib.PDFDocument.create();
            const [page] = await copiedPdf.copyPages(pdfDoc, [i]);
            copiedPdf.addPage(page);
            const singlePageBytes = await copiedPdf.save();
            pages.push({ type: 'pdf', content: singlePageBytes });
            addThumbnail(URL.createObjectURL(new Blob([singlePageBytes])), pages.length - 1, false);
          }
          originalPdfFileName = file.name.replace(/\.pdf$/i, '');
        }
        catch {
          e.target.value = ''
          return;
        }
      }
    });

    document.getElementById('imgInput').addEventListener('change', async (e) => {
      const files = e.target.files;
      for (const file of files) {
        const imageUrl = URL.createObjectURL(file);
        pages.push({ type: 'image', content: await file.arrayBuffer(), fileType: file.type });
        addThumbnail(imageUrl, pages.length - 1);
      }
    });

    function addThumbnail(url, index, isImage = true) {
      const container = document.getElementById('pages');
      const div = document.createElement('div');
      div.className = 'page-thumb';
      div.dataset.index = index;

      if (isImage) {
        const img = document.createElement('img');
        img.src = url;
        div.appendChild(img);
      } else {
        const canvas = document.createElement('canvas');
        div.appendChild(canvas);
        const loadingTask = pdfjsLib.getDocument(url);
        loadingTask.promise.then(pdf => {
          pdf.getPage(1).then(page => {
            const viewport = page.getViewport({ scale: 0.3 });
            const context = canvas.getContext('2d');
            canvas.width = viewport.width;
            canvas.height = viewport.height;
            page.render({ canvasContext: context, viewport });
          });
        });
      }

      container.appendChild(div);
    }

    new Sortable(document.getElementById('pages'), {
      animation: 150,
      onEnd: () => {
        // update pages array order
        const newOrder = [];
        const children = document.querySelectorAll('.page-thumb');
        for (const child of children) {
          const idx = parseInt(child.dataset.index);
          newOrder.push(pages[idx]);
        }
        pages = newOrder;

        // update indices
        children.forEach((child, i) => child.dataset.index = i);
      }
    });

    document.getElementById('exportBtn').addEventListener('click', async () => {
      const pdfDoc = await PDFLib.PDFDocument.create();
      for (const page of pages) {
        if (page.type === 'pdf') {
          const tempDoc = await PDFLib.PDFDocument.load(page.content);
          const [copiedPage] = await pdfDoc.copyPages(tempDoc, [0]);
          pdfDoc.addPage(copiedPage);
        } else if (page.type === 'image') {
          let imgEmbed;
          if (page.fileType === 'image/jpeg') {
            imgEmbed = await pdfDoc.embedJpg(page.content);
          } else {
            imgEmbed = await pdfDoc.embedPng(page.content);
          }
          const pageRef = pdfDoc.addPage([imgEmbed.width, imgEmbed.height]);
          pageRef.drawImage(imgEmbed, {
            x: 0,
            y: 0,
            width: imgEmbed.width,
            height: imgEmbed.height
          });
        }
      }
      const pdfBytes = await pdfDoc.save();
      const blob = new Blob([pdfBytes], { type: 'application/pdf' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = originalPdfFileName + '_pgh.pdf';;
      link.click();
    });
  </script>
</body>

</html>